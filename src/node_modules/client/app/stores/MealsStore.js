import alt from 'client/app/alt';
import moment from 'moment';

import MealsActions from 'client/app/actions/MealsActions';
import MealsSource from 'client/app/sources/MealsSource';
import NutrientsSource from 'client/app/sources/NutrientsSource';

const NUTRIENTS_MAP = [
  {id: "208", label: "Energy"},
  {id: "203", label: "Proteins"},
  {id: "204", label: "Fat"},
  {id: "205", label: "Carbohydrates"},
];

/**
 * Stores meals for given date (initically current date is used).
 * Synchronization with server can be performed with fetchMeals action. It triggers state change.
 * Date can be altered using changeDate action. Changing date doesn't trigger state change, but it
 * it automatically triggers resynchronization, which in turn trigger state change.
 */
class MealsStore {
  constructor() {
    this.date = moment();
    this.meals = [];

    this.nutrients = [];
    this.failedNutrientFetches = 0;
    this.nutrientsTodayCumulative = null;
    this.nutrientsTodayCumulativeUnits = null;

    this.bindListeners({
      handleFetch: MealsActions.FETCH_MEALS,
      handleFetchSucceess: MealsActions.FETCH_MEALS_SUCCESS,
      handleAdd: MealsActions.ADD_MEAL,
      handleAddSuccess: MealsActions.ADD_MEAL_SUCCESS,
      handleChangeDate: MealsActions.CHANGE_DATE,
      handleNutrientsFetchSuccess: MealsActions.FETCH_NUTRIENTS_SUCCESS,
      handleNutrientsFetchFailure: MealsActions.FETCH_NUTRIENTS_FAILURE,
    });
  }

  handleFetch() {
    MealsSource.fetch(this.date);
  }

  handleFetchSucceess(mealsList) {
    const todaysOnly = mealsList.filter(ml => this.date.isSame(ml.date, 'day'));
    this.setState({meals: todaysOnly});

    todaysOnly.forEach(meal => {
      NutrientsSource.fetch(meal.ndbno);
    });

    this.failedNutrientFetches = 0;
    this.nutrients = [];
  }

  handleAdd({date, name, ndbno}) {
    MealsSource.create(date, name, ndbno);
  }

  handleAddSuccess(addedMeal) {
    const modifiedMealsList = this.meals.concat([addedMeal]);
    this.setState({meals: modifiedMealsList});
  }

  handleChangeDate(newDate) {
    this.date = newDate;
    MealsActions.fetchMeals.defer();
  }

  handleNutrientsFetchSuccess(nutrientsMap) {
    this.nutrients.push(nutrientsMap);
    const allFetched = this.nutrients.length + this.failedNutrientFetches;
    if(allFetched >= this.meals.length) {
      if(allFetched > this.meals.length) {
        console.log('Warning: fetched more nutrient info than meals!');
      }

      if(this.nutrients.length > 1) {
        this._calculateChartsData();
      } else {
        console.log('All nutrient fetches failed, no charts to display');
      }
    }
  }

  handleNutrientsFetchFailure() {
    this.failedNutrientFetches += 1;
  }

  _calculateChartsData() {
    console.log('Fetched nutrients, calculating chart data');
    const cumulative = {};
    const units = {};

    this.nutrients.forEach(nutrientList => {
      nutrientList.forEach(nutrient => {
        const nid = nutrient.nutrient_id;
        if(!cumulative.hasOwnProperty(nid)) {
          const fl = parseFloat(nutrient.value);
          if(!isNaN(fl)) {
            cumulative[nid] = fl;
          }
          units[nid] = nutrient.unit;
        } else {
          const fl = parseFloat(nutrient.value);
          if(!isNaN(fl)) {
            cumulative[nid] += fl;
          }
        }
      });
    });

    NUTRIENTS_MAP.forEach(({id, label}) => {
      if(cumulative.hasOwnProperty(id)) {
        console.log(`${label}: ${cumulative[id]} ${units[id]}`);
      } else {
        cumulative[id] = 0;
        unit[id] = '';
      }
    });

    this.nutrientsTodayCumulative = cumulative;
    this.nutrientsTodayCumulativeUnits = units;
  }
}

export default alt.createStore(MealsStore, 'MealsStore');
