import alt from 'client/app/alt';
import moment from 'moment';

import MealsActions from 'client/app/actions/MealsActions';
import MealsSource from 'client/app/sources/MealsSource';
import NutrientsSource from 'client/app/sources/NutrientsSource';

/**
 * Stores meals for given date (initically current date is used).
 * Synchronization with server can be performed with fetchMeals action. It triggers state change.
 * Date can be altered using changeDate action. Changing date doesn't trigger state change, but it
 * it automatically triggers resynchronization, which in turn trigger state change.
 */
class MealsStore {
  constructor() {
    this.date = moment();
    this.meals = [];

    this._resetNutrientsData();

    this.bindListeners({
      handleFetch: MealsActions.FETCH_MEALS,
      handleFetchSucceess: MealsActions.FETCH_MEALS_SUCCESS,
      handleAdd: MealsActions.ADD_MEAL,
      handleAddSuccess: MealsActions.ADD_MEAL_SUCCESS,
      handleChangeDate: MealsActions.CHANGE_DATE,
      handleNutrientsFetchSuccess: MealsActions.FETCH_NUTRIENTS_SUCCESS,
      handleNutrientsFetchFailure: MealsActions.FETCH_NUTRIENTS_FAILURE,
    });
  }

  _resetNutrientsData() {
    this.nutrientsInMeals = [];
    this.failedNutrientFetches = 0;
    this.nutrientsTodayCumulative = null;
    this.nutrientsTodayCumulativeUnits = null;
    this.chartDataReady = false;
  }
  
  handleFetch() {
    MealsSource.fetch(this.date);
  }

  handleFetchSucceess(mealsList) {
    const todaysOnly = mealsList.filter(ml => this.date.isSame(ml.date, 'day'));
    this.setState({meals: todaysOnly});

    this._resetNutrientsData();
    
    todaysOnly.forEach(meal => {
      NutrientsSource.fetch(meal.ndbno);
    });
  }

  handleAdd({date, name, ndbno}) {
    MealsSource.create(date, name, ndbno);
  }

  handleAddSuccess(addedMeal) {
    const modifiedMealsList = this.meals.concat([addedMeal]);
    this.setState({meals: modifiedMealsList});
  }

  handleChangeDate(newDate) {
    this.date = newDate;
    MealsActions.fetchMeals.defer();
  }

  handleNutrientsFetchSuccess(nutrientsMap) {
    this.nutrientsInMeals.push(nutrientsMap);
    const allFetched = this.nutrientsInMeals.length + this.failedNutrientFetches;
    if(allFetched >= this.meals.length) {
      if(allFetched > this.meals.length) {
        console.log('Warning: fetched more nutrient info than meals!');
      }

      if(this.nutrientsInMeals.length > 1) {
        this._calculateChartsData();
      } else {
        console.log('All nutrient fetches failed, no charts to display');
      }
    }
  }

  handleNutrientsFetchFailure() {
    this.failedNutrientFetches += 1;
  }

  _calculateChartsData() {
    console.log('Fetched nutrients, calculating chart data');
    const cumulative = {};
    const units = {};

    function parseNutValue(nutrient) {
      const fl = parseFloat(nutrient.value);
      if(!isNaN(fl)) {
        return fl;
      } else {
        return 0.0;
      }
    }

    // sum all available nutrients
    this.nutrientsInMeals.forEach(nutrientList => {
      nutrientList.forEach(nutrient => {
        const nid = nutrient.nutrient_id;

        if(!cumulative.hasOwnProperty(nid)) {
          cumulative[nid] = parseNutValue(nutrient);
          units[nid] = nutrient.unit;
        } else {
          cumulative[nid] += parseNutValue(nutrient);
        }
      });
    });

    this.nutrientsTodayCumulative = cumulative;
    this.nutrientsTodayCumulativeUnits = units;
    this.chartDataReady = true;
  }
}

export default alt.createStore(MealsStore, 'MealsStore');
