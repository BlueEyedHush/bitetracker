
import {ObjectId} from 'mongodb';

import BaseDao from 'server/db/BaseDao';
import ValidationMixin from 'server/db/ValidationMixin';
import {wrapAndCheckId} from 'server/db/id';
import {createException as ex} from 'shared/exceptions';
import {mix} from 'mixwith';

const groceryListSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string'
    },
    completed: {
      type: 'boolean'
    }
  },
  required: ['title', 'completed'],
};

export class GroceryListDao extends ValidationMixin(BaseDao) {
  constructor(db) {
    super(groceryListSchema /* arg for ValidationMixin */, db, 'grocery_lists' /* arg for BaseDao */);
  }

  static create(title, completed) {
    return {title, completed: completed || false};
  }

  /** @return Promise resolving:
   * - on success: to array of documents
   * - on failure: to MongoError with cause of the problems
   *
   * There is no need to explicitly close cursor in this case since toArray exhausts it, and
   * Mongo documentation says that exhausted cursors are closed automatically by the server
   */
  getAll() {
    return this.getCollection()
      .then(c => c.find().toArray())
      .then(arr => arr.map(d => {
        d._id = d._id.toHexString();
        return d;
      }));
  };

  /**
   *
   * @param o - object to validate (and insert in case it's valid); this method mutates input data!
   * @returns Promise resolving:
   * - on success: inserted document (with defaults filled in and _id field of type string)
   * - on invalid input: to Error(name = 'validation_error')
   * - on database error: to MongoError containing the details
   */
  insert(o) {
    /* validate adds default values and removes properties that are not in model */
    return Promise.resolve()
      /* if the input is invalid this'll throw exception and Promise'll reject with validation_error */
      .then(() => this.validate(o))
      .then(validInput => {
        return this.getCollection()
          .then(c => c.insertOne(validInput))
          .then(result => result.ops[0])
          .then(d => {
            d._id = d._id.toHexString();
            return d;
          });
      });
  };

  /**
   *
   * @param id String
   * @returns Promise which:
   * - on success resolves to document,
   * - on document not found rejects with 'not_found' exception
   * - on invalid id rejects with invalid_argument error
   * - on database error rejects with MongoError
     */
  getOne(id) {
    return this.getCollection()
      .then(c => c.findOne({_id: wrapAndCheckId(id)}))
      .then(r => {
        if(r == null) throw ex('not_found', 'no document with such ID');
        else return r;
      });
  };

  /**
   *
   * @param id - String
   * @param update - object describing updates which should be applied
   * @returns Promise which:
   * - on success resolves without returning anything
   * - on id not found rejects with not_found exception
   * - on invalid update rejects with 'validation_error' Error
   * - on database error rejects with MongoError
     */
  update(id, update) {
    return Promise.resolve()
      .then(() => this.validateUpdate(update))
      .then(validUpdate => {
        this.getCollection()
          .then(c => c.updateOne({_id: wrapAndCheckId(id)}, {$set: update}))
          .then(r => {
            if(r.matchedCount == 0) throw ex('not_found', 'no document with such ID');
            else return Promise.resolve();
          })
      })
  };

  /**
   *
   * @param id - String
   * @returns Promise which:
   * - on success resolves without returning anything
   * - on id not found rejects with 'not_found' error
   * - on database error rejects with MongoError
   */
  remove(id) {
    return this.getCollection().then(c => c.deleteOne({_id: wrapAndCheckId(id)}))
      .then(r => {
        if(r.deletedCount === 0) throw ex('not_found', 'no document with such ID')
        else return Promise.resolve()
      });
  };
}
