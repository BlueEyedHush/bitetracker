import {login, EX as authEx, __RewireAPI__ as authRewire} from 'client/sharedjs/auth';
import cookies from 'js-cookie';

const LOCAL_AUTH_URL = authRewire.__get__('LOCAL_AUTH_URL');
const USERID_COOKIE_NAME = authRewire.__get__('USERID_COOKIE_NAME');
const REDIRURL_COOKIE_NAME = authRewire.__get__('REDIRURL_COOKIE_NAME');

const credentials = {username: 'test', password: 'pass'};

function removeCookies() {
  cookies.remove('user');
  cookies.remove('redirUrl');
}

let promise, requestStub;
function setupWithRespone(response) {
  requestStub = sinon.stub().withArgs(LOCAL_AUTH_URL).returns(Promise.resolve(response));
  authRewire.__Rewire__('axios', {
    post: requestStub
  });
  promise = login(credentials.username, credentials.password);
}


describe('auth', () => {
  afterEach(() => authRewire.__ResetDependency__('axios'));

  context('http200', () => {
    const response = new Response(JSON.stringify({userId: '123', redirectUrl: '/redirect.html'}), {status: 200});

    before(() => setupWithRespone(response));

    after(() => removeCookies());

    it('should resolve', () => {
      promise.should.be.fulfilled;
    });

    it('should be resolved with correct argument: [resp, json]', () => {
      promise.should.eventually.have.lengthOf(2);
    });

    it('should call local auth service', () => {
      expect(requestStub).to.have.been.calledWith(LOCAL_AUTH_URL, credentials);
    });

    context('when promise resolves', () => {
      it('user" cookie should be set', () => {
        expect(cookies.get(USERID_COOKIE_NAME))
          .to.be.equal(response.userId);
      });

      it('"redirUrl" cookie should be set', () => {
        expect(cookies.get(REDIRURL_COOKIE_NAME))
          .to.be.equal(response.redirectUrl);
      });
    });
  });

  context('http403', () => {
    const response = new Response(JSON.stringify({message: 'any message'}), {status: 403});

    before(() => setupWithRespone(response));

    it('should reject with correct error type', () => {
      promise.should.be.rejected
        .and.eventually.have.property('name', authEx.INCORRECT_CREDENTIALS);
    });
  });

  context('http500', () => {
    const response = new Response('', {status: 500});

    before(() => setupWithRespone(response));

    it('should reject with correct error type', () => {
      promise.should.be.rejected
        .and.eventually.have.property('name', authEx.UNKNOWN);
    });
  });

  context('http200 with malformed payload', () => {
    const response = new Response('{abc');

    before(() => setupWithRespone(response));

    it('should reject with UNKNOWN error type', () => {
      promise.should.be.rejected
        .and.eventually.have.property('name', authEx.UNKNOWN);
    });
  });
});
