'use strict';

import {expressHandler, initAppAndPrepareDb} from 'tests/server/integration/utils';
import request from 'supertest-as-promised';
import logger from 'winston';

import {getApp} from 'server/app';
import {GroceryListDao} from 'server/api/grocery_list/GroceryListDao';

const mainUrl = '/api/grocery_list';
const listUrl = `${mainUrl}/{list_id}`;
const itemsUrl = `${listUrl}/items`;
const itemUrl = `${itemsUrl}/{item_id}`;

class Helpers {
  constructor(dao, eh) {
    this.dao = dao;
    this.eh = eh;
  }

  insertNew() {
    return this.dao.insert(GroceryListDao.create(this.getRandomString(), false)).then(d => d._id);
  }

  /* returns Promise which resolves to list of inserted documents */
  insertLists() {
    return Promise.all([1,2,3].map(_ => this.insertNew()));
  }

  /* @todo: fix lack of title
   * returns Promise, which resolves to id of the posted document */
  postNew() {
    return request(this.eh)
      .post(mainUrl)
      .set('Content-Type', 'application/json')
      .send({title: this.getRandomString(), completed: false})
      .expect(201)
      .then(response => response.body._id);
  }

  getRandomString() {
    return Math.random().toString(36).substr(0, 8);
  }
}

const suiteName = 'Grocer List API';
var eh;
var dao;
var helpers;

/* problem - if one fails, everything goes down the drain... */

initAppAndPrepareDb()
  /* setup needed for all tests */
  .then((app) => {
    eh = app.getExpressHandler();
    dao = new GroceryListDao(app.getDatabase());
    helpers = new Helpers(dao, eh);
  })
  /* T1: let's insert lists tht we'll want to retrieve */
  .then(() => helpers.insertLists())
  /* T1: now we have to make request */
  .then((insertedIds) => {
    return request(eh)
      .get(mainUrl)
      .set('Content-Type', 'application/json')
      .expect(200)
      .then(resp => ({insertedIds, rBody: resp.body}));
  })
  /* T1: verification step */
  .then(({insertedIds, rBody}) => {
    describe(`${suiteName}: GET ${mainUrl}`, () => {
      it('should return all lists', () => {
        expect(rBody.map(gl => gl._id)).to.deep.include.members(insertedIds);
      });
    })
  })
  /* T2: we're gonna test posting, so database needs to be cleaned first */
  .then(() => dao.clean())
  .then(() => helpers.postNew())
  .then((id) => {
    describe(`${suiteName}: POST ${mainUrl}`, () => {
      it('should create new grocery list', () => {
        return dao.getOne(id)
          .then(list => expect(list).to.be.not.null);
      });
    });
  })
  /* T3: */
  .then(() => helpers.insertNew())
  .then(id => {
    describe(`${suiteName}: GET ${listUrl}`, () => {
      it('should return item with given id', () => {
        return request(eh)
          .get(listUrl.replace('{list_id}', id))
          .set('Content-Type', 'application/json')
          .expect(200)
          .then(res => expect(res.body._id).to.be.equal(id));
      });
    });
  })
  /* T4 */
  .then(() => helpers.insertNew())
  .then((id) => {
    const newTitle = 'new_title';

    return request(eh)
      .patch(listUrl.replace('{list_id}', id))
      .set('Content-Type', 'application/json')
      .send({title: newTitle})
      .expect(204)
      .then(_ => dao.getOne(id))
      .then(list => ({newTitle, list}));
  })
  .then(({newTitle, list}) => {
    describe(`${suiteName}: PATCH ${listUrl}`, () => {
      it('should modify list name', () => {
        expect(list.title).to.be.equal(newTitle);
      });
    });
  })
  /* T5 */
  .then(() => helpers.insertNew())
  .then((id) => {
    return request(eh)
      .delete(listUrl.replace('{list_id}', id))
      .set('Content-Type', 'application/json')
      .expect(204)
      .then(_ => dao.getOne(id))
      .catch(() => null)
  })
  .then(list => {
    describe(`${suiteName}: DELETE ${listUrl}`, () => {
      it('should remove the list', () => {
        expect(list).to.be.null;
      });
    });
  })
  /* T6 */
  .then(() => helpers.insertNew())
  .then((id) => {
    return request(eh)
      .patch(listUrl.replace('{list_id}', id))
      .set('Content-Type', 'application/json')
      .send({completed: true})
      .expect(204)
      .then(_ => dao.getOne(id));
  })
  .then(list => {
    describe(`${suiteName}: PATCH ${listUrl}`, () => {
      it('should mark list as completed', () => {
        expect(list.completed).to.be.true;
      });
    });
  })
  /* let mocha know that it can verify the test results */
  .then(() => run())
  .catch((err) => {
    logger.error(err.stack);
    process.exit(1);
  });
